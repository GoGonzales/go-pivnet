// This file was generated by counterfeiter
package filegroupfakes

import (
	"sync"

	pivnet "github.com/pivotal-cf-experimental/go-pivnet"
	"github.com/pivotal-cf-experimental/go-pivnet/cmd/pivnet/commands/filegroup"
)

type FakePivnetClient struct {
	FileGroupsStub        func(productSlug string) ([]pivnet.FileGroup, error)
	fileGroupsMutex       sync.RWMutex
	fileGroupsArgsForCall []struct {
		productSlug string
	}
	fileGroupsReturns struct {
		result1 []pivnet.FileGroup
		result2 error
	}
	FileGroupsForReleaseStub        func(productSlug string, releaseID int) ([]pivnet.FileGroup, error)
	fileGroupsForReleaseMutex       sync.RWMutex
	fileGroupsForReleaseArgsForCall []struct {
		productSlug string
		releaseID   int
	}
	fileGroupsForReleaseReturns struct {
		result1 []pivnet.FileGroup
		result2 error
	}
	ReleaseForProductVersionStub        func(productSlug string, releaseVersion string) (pivnet.Release, error)
	releaseForProductVersionMutex       sync.RWMutex
	releaseForProductVersionArgsForCall []struct {
		productSlug    string
		releaseVersion string
	}
	releaseForProductVersionReturns struct {
		result1 pivnet.Release
		result2 error
	}
	FileGroupStub        func(productSlug string, fileGroupID int) (pivnet.FileGroup, error)
	fileGroupMutex       sync.RWMutex
	fileGroupArgsForCall []struct {
		productSlug string
		fileGroupID int
	}
	fileGroupReturns struct {
		result1 pivnet.FileGroup
		result2 error
	}
	DeleteFileGroupStub        func(productSlug string, fileGroupID int) (pivnet.FileGroup, error)
	deleteFileGroupMutex       sync.RWMutex
	deleteFileGroupArgsForCall []struct {
		productSlug string
		fileGroupID int
	}
	deleteFileGroupReturns struct {
		result1 pivnet.FileGroup
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePivnetClient) FileGroups(productSlug string) ([]pivnet.FileGroup, error) {
	fake.fileGroupsMutex.Lock()
	fake.fileGroupsArgsForCall = append(fake.fileGroupsArgsForCall, struct {
		productSlug string
	}{productSlug})
	fake.recordInvocation("FileGroups", []interface{}{productSlug})
	fake.fileGroupsMutex.Unlock()
	if fake.FileGroupsStub != nil {
		return fake.FileGroupsStub(productSlug)
	} else {
		return fake.fileGroupsReturns.result1, fake.fileGroupsReturns.result2
	}
}

func (fake *FakePivnetClient) FileGroupsCallCount() int {
	fake.fileGroupsMutex.RLock()
	defer fake.fileGroupsMutex.RUnlock()
	return len(fake.fileGroupsArgsForCall)
}

func (fake *FakePivnetClient) FileGroupsArgsForCall(i int) string {
	fake.fileGroupsMutex.RLock()
	defer fake.fileGroupsMutex.RUnlock()
	return fake.fileGroupsArgsForCall[i].productSlug
}

func (fake *FakePivnetClient) FileGroupsReturns(result1 []pivnet.FileGroup, result2 error) {
	fake.FileGroupsStub = nil
	fake.fileGroupsReturns = struct {
		result1 []pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) FileGroupsForRelease(productSlug string, releaseID int) ([]pivnet.FileGroup, error) {
	fake.fileGroupsForReleaseMutex.Lock()
	fake.fileGroupsForReleaseArgsForCall = append(fake.fileGroupsForReleaseArgsForCall, struct {
		productSlug string
		releaseID   int
	}{productSlug, releaseID})
	fake.recordInvocation("FileGroupsForRelease", []interface{}{productSlug, releaseID})
	fake.fileGroupsForReleaseMutex.Unlock()
	if fake.FileGroupsForReleaseStub != nil {
		return fake.FileGroupsForReleaseStub(productSlug, releaseID)
	} else {
		return fake.fileGroupsForReleaseReturns.result1, fake.fileGroupsForReleaseReturns.result2
	}
}

func (fake *FakePivnetClient) FileGroupsForReleaseCallCount() int {
	fake.fileGroupsForReleaseMutex.RLock()
	defer fake.fileGroupsForReleaseMutex.RUnlock()
	return len(fake.fileGroupsForReleaseArgsForCall)
}

func (fake *FakePivnetClient) FileGroupsForReleaseArgsForCall(i int) (string, int) {
	fake.fileGroupsForReleaseMutex.RLock()
	defer fake.fileGroupsForReleaseMutex.RUnlock()
	return fake.fileGroupsForReleaseArgsForCall[i].productSlug, fake.fileGroupsForReleaseArgsForCall[i].releaseID
}

func (fake *FakePivnetClient) FileGroupsForReleaseReturns(result1 []pivnet.FileGroup, result2 error) {
	fake.FileGroupsForReleaseStub = nil
	fake.fileGroupsForReleaseReturns = struct {
		result1 []pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ReleaseForProductVersion(productSlug string, releaseVersion string) (pivnet.Release, error) {
	fake.releaseForProductVersionMutex.Lock()
	fake.releaseForProductVersionArgsForCall = append(fake.releaseForProductVersionArgsForCall, struct {
		productSlug    string
		releaseVersion string
	}{productSlug, releaseVersion})
	fake.recordInvocation("ReleaseForProductVersion", []interface{}{productSlug, releaseVersion})
	fake.releaseForProductVersionMutex.Unlock()
	if fake.ReleaseForProductVersionStub != nil {
		return fake.ReleaseForProductVersionStub(productSlug, releaseVersion)
	} else {
		return fake.releaseForProductVersionReturns.result1, fake.releaseForProductVersionReturns.result2
	}
}

func (fake *FakePivnetClient) ReleaseForProductVersionCallCount() int {
	fake.releaseForProductVersionMutex.RLock()
	defer fake.releaseForProductVersionMutex.RUnlock()
	return len(fake.releaseForProductVersionArgsForCall)
}

func (fake *FakePivnetClient) ReleaseForProductVersionArgsForCall(i int) (string, string) {
	fake.releaseForProductVersionMutex.RLock()
	defer fake.releaseForProductVersionMutex.RUnlock()
	return fake.releaseForProductVersionArgsForCall[i].productSlug, fake.releaseForProductVersionArgsForCall[i].releaseVersion
}

func (fake *FakePivnetClient) ReleaseForProductVersionReturns(result1 pivnet.Release, result2 error) {
	fake.ReleaseForProductVersionStub = nil
	fake.releaseForProductVersionReturns = struct {
		result1 pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) FileGroup(productSlug string, fileGroupID int) (pivnet.FileGroup, error) {
	fake.fileGroupMutex.Lock()
	fake.fileGroupArgsForCall = append(fake.fileGroupArgsForCall, struct {
		productSlug string
		fileGroupID int
	}{productSlug, fileGroupID})
	fake.recordInvocation("FileGroup", []interface{}{productSlug, fileGroupID})
	fake.fileGroupMutex.Unlock()
	if fake.FileGroupStub != nil {
		return fake.FileGroupStub(productSlug, fileGroupID)
	} else {
		return fake.fileGroupReturns.result1, fake.fileGroupReturns.result2
	}
}

func (fake *FakePivnetClient) FileGroupCallCount() int {
	fake.fileGroupMutex.RLock()
	defer fake.fileGroupMutex.RUnlock()
	return len(fake.fileGroupArgsForCall)
}

func (fake *FakePivnetClient) FileGroupArgsForCall(i int) (string, int) {
	fake.fileGroupMutex.RLock()
	defer fake.fileGroupMutex.RUnlock()
	return fake.fileGroupArgsForCall[i].productSlug, fake.fileGroupArgsForCall[i].fileGroupID
}

func (fake *FakePivnetClient) FileGroupReturns(result1 pivnet.FileGroup, result2 error) {
	fake.FileGroupStub = nil
	fake.fileGroupReturns = struct {
		result1 pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) DeleteFileGroup(productSlug string, fileGroupID int) (pivnet.FileGroup, error) {
	fake.deleteFileGroupMutex.Lock()
	fake.deleteFileGroupArgsForCall = append(fake.deleteFileGroupArgsForCall, struct {
		productSlug string
		fileGroupID int
	}{productSlug, fileGroupID})
	fake.recordInvocation("DeleteFileGroup", []interface{}{productSlug, fileGroupID})
	fake.deleteFileGroupMutex.Unlock()
	if fake.DeleteFileGroupStub != nil {
		return fake.DeleteFileGroupStub(productSlug, fileGroupID)
	} else {
		return fake.deleteFileGroupReturns.result1, fake.deleteFileGroupReturns.result2
	}
}

func (fake *FakePivnetClient) DeleteFileGroupCallCount() int {
	fake.deleteFileGroupMutex.RLock()
	defer fake.deleteFileGroupMutex.RUnlock()
	return len(fake.deleteFileGroupArgsForCall)
}

func (fake *FakePivnetClient) DeleteFileGroupArgsForCall(i int) (string, int) {
	fake.deleteFileGroupMutex.RLock()
	defer fake.deleteFileGroupMutex.RUnlock()
	return fake.deleteFileGroupArgsForCall[i].productSlug, fake.deleteFileGroupArgsForCall[i].fileGroupID
}

func (fake *FakePivnetClient) DeleteFileGroupReturns(result1 pivnet.FileGroup, result2 error) {
	fake.DeleteFileGroupStub = nil
	fake.deleteFileGroupReturns = struct {
		result1 pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.fileGroupsMutex.RLock()
	defer fake.fileGroupsMutex.RUnlock()
	fake.fileGroupsForReleaseMutex.RLock()
	defer fake.fileGroupsForReleaseMutex.RUnlock()
	fake.releaseForProductVersionMutex.RLock()
	defer fake.releaseForProductVersionMutex.RUnlock()
	fake.fileGroupMutex.RLock()
	defer fake.fileGroupMutex.RUnlock()
	fake.deleteFileGroupMutex.RLock()
	defer fake.deleteFileGroupMutex.RUnlock()
	return fake.invocations
}

func (fake *FakePivnetClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ filegroup.PivnetClient = new(FakePivnetClient)
