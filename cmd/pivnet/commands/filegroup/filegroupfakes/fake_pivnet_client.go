// This file was generated by counterfeiter
package filegroupfakes

import (
	"sync"

	pivnet "github.com/pivotal-cf-experimental/go-pivnet"
	"github.com/pivotal-cf-experimental/go-pivnet/cmd/pivnet/commands/filegroup"
)

type FakePivnetClient struct {
	FileGroupsStub        func(productSlug string) ([]pivnet.FileGroup, error)
	fileGroupsMutex       sync.RWMutex
	fileGroupsArgsForCall []struct {
		productSlug string
	}
	fileGroupsReturns struct {
		result1 []pivnet.FileGroup
		result2 error
	}
	FileGroupsForReleaseStub        func(productSlug string, releaseID int) ([]pivnet.FileGroup, error)
	fileGroupsForReleaseMutex       sync.RWMutex
	fileGroupsForReleaseArgsForCall []struct {
		productSlug string
		releaseID   int
	}
	fileGroupsForReleaseReturns struct {
		result1 []pivnet.FileGroup
		result2 error
	}
	ReleaseForProductVersionStub        func(productSlug string, releaseVersion string) (pivnet.Release, error)
	releaseForProductVersionMutex       sync.RWMutex
	releaseForProductVersionArgsForCall []struct {
		productSlug    string
		releaseVersion string
	}
	releaseForProductVersionReturns struct {
		result1 pivnet.Release
		result2 error
	}
	FileGroupStub        func(productSlug string, fileGroupID int) (pivnet.FileGroup, error)
	fileGroupMutex       sync.RWMutex
	fileGroupArgsForCall []struct {
		productSlug string
		fileGroupID int
	}
	fileGroupReturns struct {
		result1 pivnet.FileGroup
		result2 error
	}
	CreateFileGroupStub        func(productSlug string, name string) (pivnet.FileGroup, error)
	createFileGroupMutex       sync.RWMutex
	createFileGroupArgsForCall []struct {
		productSlug string
		name        string
	}
	createFileGroupReturns struct {
		result1 pivnet.FileGroup
		result2 error
	}
	UpdateFileGroupStub        func(productSlug string, fileGroup pivnet.FileGroup) (pivnet.FileGroup, error)
	updateFileGroupMutex       sync.RWMutex
	updateFileGroupArgsForCall []struct {
		productSlug string
		fileGroup   pivnet.FileGroup
	}
	updateFileGroupReturns struct {
		result1 pivnet.FileGroup
		result2 error
	}
	DeleteFileGroupStub        func(productSlug string, fileGroupID int) (pivnet.FileGroup, error)
	deleteFileGroupMutex       sync.RWMutex
	deleteFileGroupArgsForCall []struct {
		productSlug string
		fileGroupID int
	}
	deleteFileGroupReturns struct {
		result1 pivnet.FileGroup
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePivnetClient) FileGroups(productSlug string) ([]pivnet.FileGroup, error) {
	fake.fileGroupsMutex.Lock()
	fake.fileGroupsArgsForCall = append(fake.fileGroupsArgsForCall, struct {
		productSlug string
	}{productSlug})
	fake.recordInvocation("FileGroups", []interface{}{productSlug})
	fake.fileGroupsMutex.Unlock()
	if fake.FileGroupsStub != nil {
		return fake.FileGroupsStub(productSlug)
	} else {
		return fake.fileGroupsReturns.result1, fake.fileGroupsReturns.result2
	}
}

func (fake *FakePivnetClient) FileGroupsCallCount() int {
	fake.fileGroupsMutex.RLock()
	defer fake.fileGroupsMutex.RUnlock()
	return len(fake.fileGroupsArgsForCall)
}

func (fake *FakePivnetClient) FileGroupsArgsForCall(i int) string {
	fake.fileGroupsMutex.RLock()
	defer fake.fileGroupsMutex.RUnlock()
	return fake.fileGroupsArgsForCall[i].productSlug
}

func (fake *FakePivnetClient) FileGroupsReturns(result1 []pivnet.FileGroup, result2 error) {
	fake.FileGroupsStub = nil
	fake.fileGroupsReturns = struct {
		result1 []pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) FileGroupsForRelease(productSlug string, releaseID int) ([]pivnet.FileGroup, error) {
	fake.fileGroupsForReleaseMutex.Lock()
	fake.fileGroupsForReleaseArgsForCall = append(fake.fileGroupsForReleaseArgsForCall, struct {
		productSlug string
		releaseID   int
	}{productSlug, releaseID})
	fake.recordInvocation("FileGroupsForRelease", []interface{}{productSlug, releaseID})
	fake.fileGroupsForReleaseMutex.Unlock()
	if fake.FileGroupsForReleaseStub != nil {
		return fake.FileGroupsForReleaseStub(productSlug, releaseID)
	} else {
		return fake.fileGroupsForReleaseReturns.result1, fake.fileGroupsForReleaseReturns.result2
	}
}

func (fake *FakePivnetClient) FileGroupsForReleaseCallCount() int {
	fake.fileGroupsForReleaseMutex.RLock()
	defer fake.fileGroupsForReleaseMutex.RUnlock()
	return len(fake.fileGroupsForReleaseArgsForCall)
}

func (fake *FakePivnetClient) FileGroupsForReleaseArgsForCall(i int) (string, int) {
	fake.fileGroupsForReleaseMutex.RLock()
	defer fake.fileGroupsForReleaseMutex.RUnlock()
	return fake.fileGroupsForReleaseArgsForCall[i].productSlug, fake.fileGroupsForReleaseArgsForCall[i].releaseID
}

func (fake *FakePivnetClient) FileGroupsForReleaseReturns(result1 []pivnet.FileGroup, result2 error) {
	fake.FileGroupsForReleaseStub = nil
	fake.fileGroupsForReleaseReturns = struct {
		result1 []pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ReleaseForProductVersion(productSlug string, releaseVersion string) (pivnet.Release, error) {
	fake.releaseForProductVersionMutex.Lock()
	fake.releaseForProductVersionArgsForCall = append(fake.releaseForProductVersionArgsForCall, struct {
		productSlug    string
		releaseVersion string
	}{productSlug, releaseVersion})
	fake.recordInvocation("ReleaseForProductVersion", []interface{}{productSlug, releaseVersion})
	fake.releaseForProductVersionMutex.Unlock()
	if fake.ReleaseForProductVersionStub != nil {
		return fake.ReleaseForProductVersionStub(productSlug, releaseVersion)
	} else {
		return fake.releaseForProductVersionReturns.result1, fake.releaseForProductVersionReturns.result2
	}
}

func (fake *FakePivnetClient) ReleaseForProductVersionCallCount() int {
	fake.releaseForProductVersionMutex.RLock()
	defer fake.releaseForProductVersionMutex.RUnlock()
	return len(fake.releaseForProductVersionArgsForCall)
}

func (fake *FakePivnetClient) ReleaseForProductVersionArgsForCall(i int) (string, string) {
	fake.releaseForProductVersionMutex.RLock()
	defer fake.releaseForProductVersionMutex.RUnlock()
	return fake.releaseForProductVersionArgsForCall[i].productSlug, fake.releaseForProductVersionArgsForCall[i].releaseVersion
}

func (fake *FakePivnetClient) ReleaseForProductVersionReturns(result1 pivnet.Release, result2 error) {
	fake.ReleaseForProductVersionStub = nil
	fake.releaseForProductVersionReturns = struct {
		result1 pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) FileGroup(productSlug string, fileGroupID int) (pivnet.FileGroup, error) {
	fake.fileGroupMutex.Lock()
	fake.fileGroupArgsForCall = append(fake.fileGroupArgsForCall, struct {
		productSlug string
		fileGroupID int
	}{productSlug, fileGroupID})
	fake.recordInvocation("FileGroup", []interface{}{productSlug, fileGroupID})
	fake.fileGroupMutex.Unlock()
	if fake.FileGroupStub != nil {
		return fake.FileGroupStub(productSlug, fileGroupID)
	} else {
		return fake.fileGroupReturns.result1, fake.fileGroupReturns.result2
	}
}

func (fake *FakePivnetClient) FileGroupCallCount() int {
	fake.fileGroupMutex.RLock()
	defer fake.fileGroupMutex.RUnlock()
	return len(fake.fileGroupArgsForCall)
}

func (fake *FakePivnetClient) FileGroupArgsForCall(i int) (string, int) {
	fake.fileGroupMutex.RLock()
	defer fake.fileGroupMutex.RUnlock()
	return fake.fileGroupArgsForCall[i].productSlug, fake.fileGroupArgsForCall[i].fileGroupID
}

func (fake *FakePivnetClient) FileGroupReturns(result1 pivnet.FileGroup, result2 error) {
	fake.FileGroupStub = nil
	fake.fileGroupReturns = struct {
		result1 pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) CreateFileGroup(productSlug string, name string) (pivnet.FileGroup, error) {
	fake.createFileGroupMutex.Lock()
	fake.createFileGroupArgsForCall = append(fake.createFileGroupArgsForCall, struct {
		productSlug string
		name        string
	}{productSlug, name})
	fake.recordInvocation("CreateFileGroup", []interface{}{productSlug, name})
	fake.createFileGroupMutex.Unlock()
	if fake.CreateFileGroupStub != nil {
		return fake.CreateFileGroupStub(productSlug, name)
	} else {
		return fake.createFileGroupReturns.result1, fake.createFileGroupReturns.result2
	}
}

func (fake *FakePivnetClient) CreateFileGroupCallCount() int {
	fake.createFileGroupMutex.RLock()
	defer fake.createFileGroupMutex.RUnlock()
	return len(fake.createFileGroupArgsForCall)
}

func (fake *FakePivnetClient) CreateFileGroupArgsForCall(i int) (string, string) {
	fake.createFileGroupMutex.RLock()
	defer fake.createFileGroupMutex.RUnlock()
	return fake.createFileGroupArgsForCall[i].productSlug, fake.createFileGroupArgsForCall[i].name
}

func (fake *FakePivnetClient) CreateFileGroupReturns(result1 pivnet.FileGroup, result2 error) {
	fake.CreateFileGroupStub = nil
	fake.createFileGroupReturns = struct {
		result1 pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) UpdateFileGroup(productSlug string, fileGroup pivnet.FileGroup) (pivnet.FileGroup, error) {
	fake.updateFileGroupMutex.Lock()
	fake.updateFileGroupArgsForCall = append(fake.updateFileGroupArgsForCall, struct {
		productSlug string
		fileGroup   pivnet.FileGroup
	}{productSlug, fileGroup})
	fake.recordInvocation("UpdateFileGroup", []interface{}{productSlug, fileGroup})
	fake.updateFileGroupMutex.Unlock()
	if fake.UpdateFileGroupStub != nil {
		return fake.UpdateFileGroupStub(productSlug, fileGroup)
	} else {
		return fake.updateFileGroupReturns.result1, fake.updateFileGroupReturns.result2
	}
}

func (fake *FakePivnetClient) UpdateFileGroupCallCount() int {
	fake.updateFileGroupMutex.RLock()
	defer fake.updateFileGroupMutex.RUnlock()
	return len(fake.updateFileGroupArgsForCall)
}

func (fake *FakePivnetClient) UpdateFileGroupArgsForCall(i int) (string, pivnet.FileGroup) {
	fake.updateFileGroupMutex.RLock()
	defer fake.updateFileGroupMutex.RUnlock()
	return fake.updateFileGroupArgsForCall[i].productSlug, fake.updateFileGroupArgsForCall[i].fileGroup
}

func (fake *FakePivnetClient) UpdateFileGroupReturns(result1 pivnet.FileGroup, result2 error) {
	fake.UpdateFileGroupStub = nil
	fake.updateFileGroupReturns = struct {
		result1 pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) DeleteFileGroup(productSlug string, fileGroupID int) (pivnet.FileGroup, error) {
	fake.deleteFileGroupMutex.Lock()
	fake.deleteFileGroupArgsForCall = append(fake.deleteFileGroupArgsForCall, struct {
		productSlug string
		fileGroupID int
	}{productSlug, fileGroupID})
	fake.recordInvocation("DeleteFileGroup", []interface{}{productSlug, fileGroupID})
	fake.deleteFileGroupMutex.Unlock()
	if fake.DeleteFileGroupStub != nil {
		return fake.DeleteFileGroupStub(productSlug, fileGroupID)
	} else {
		return fake.deleteFileGroupReturns.result1, fake.deleteFileGroupReturns.result2
	}
}

func (fake *FakePivnetClient) DeleteFileGroupCallCount() int {
	fake.deleteFileGroupMutex.RLock()
	defer fake.deleteFileGroupMutex.RUnlock()
	return len(fake.deleteFileGroupArgsForCall)
}

func (fake *FakePivnetClient) DeleteFileGroupArgsForCall(i int) (string, int) {
	fake.deleteFileGroupMutex.RLock()
	defer fake.deleteFileGroupMutex.RUnlock()
	return fake.deleteFileGroupArgsForCall[i].productSlug, fake.deleteFileGroupArgsForCall[i].fileGroupID
}

func (fake *FakePivnetClient) DeleteFileGroupReturns(result1 pivnet.FileGroup, result2 error) {
	fake.DeleteFileGroupStub = nil
	fake.deleteFileGroupReturns = struct {
		result1 pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.fileGroupsMutex.RLock()
	defer fake.fileGroupsMutex.RUnlock()
	fake.fileGroupsForReleaseMutex.RLock()
	defer fake.fileGroupsForReleaseMutex.RUnlock()
	fake.releaseForProductVersionMutex.RLock()
	defer fake.releaseForProductVersionMutex.RUnlock()
	fake.fileGroupMutex.RLock()
	defer fake.fileGroupMutex.RUnlock()
	fake.createFileGroupMutex.RLock()
	defer fake.createFileGroupMutex.RUnlock()
	fake.updateFileGroupMutex.RLock()
	defer fake.updateFileGroupMutex.RUnlock()
	fake.deleteFileGroupMutex.RLock()
	defer fake.deleteFileGroupMutex.RUnlock()
	return fake.invocations
}

func (fake *FakePivnetClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ filegroup.PivnetClient = new(FakePivnetClient)
